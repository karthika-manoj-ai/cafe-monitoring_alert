import cv2
import time
import threading
import os
import torch
import winsound
from collections import deque
from ultralytics import YOLO
from gtts import gTTS
from playsound import playsound
from PIL import Image
from transformers import Qwen2VLForConditionalGeneration, AutoProcessor

# =============================
# CONFIG
# =============================
CAMERA_ID = 0
OVER_CROWD_LIMIT = 2
SMOOTHING_WINDOW = 5
CONF_THRESHOLD = 0.4
ALERT_REPEAT_INTERVAL = 5
VLM_CHECK_INTERVAL = 5   # seconds

BEEP_FREQ = 1000
BEEP_DURATION = 500
AUDIO_FILE = "alert.mp3"

# =============================
# LOAD YOLO
# =============================
print("Loading YOLO...")
yolo_model = YOLO("yolov8n.pt")
print("YOLO loaded")

# =============================
# LOAD QWEN2-VL (CPU SAFE)
# =============================
print("Loading Qwen2-VL (CPU mode)...")

vl_model = Qwen2VLForConditionalGeneration.from_pretrained(
    "Qwen/Qwen2-VL-2B-Instruct",
    torch_dtype=torch.float32
).to("cpu")

vl_processor = AutoProcessor.from_pretrained(
    "Qwen/Qwen2-VL-2B-Instruct",
    use_fast=False
)

print("Qwen2-VL loaded")

# =============================
# PRE-GENERATE AUDIO
# =============================
if not os.path.exists(AUDIO_FILE):
    tts = gTTS("Alert. The cafe is overcrowded.", lang="en")
    tts.save(AUDIO_FILE)

# =============================
# ALERT THREAD CONTROL
# =============================
alert_active = False
alert_thread_running = False

def alert_loop():
    global alert_thread_running
    alert_thread_running = True
    while alert_active:
        winsound.Beep(BEEP_FREQ, BEEP_DURATION)
        playsound(AUDIO_FILE)
        time.sleep(ALERT_REPEAT_INTERVAL)
    alert_thread_running = False

# =============================
# VLM ASYNC STATE
# =============================
vlm_busy = False
vlm_result = False
last_vlm_check = 0

# =============================
# QWEN2-VL CONFIRM FUNCTION
# =============================
def qwen_confirm_overcrowding(frame):
    image = Image.fromarray(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB))

    messages = [{
        "role": "user",
        "content": [
            {"type": "image"},
            {"type": "text",
             "text": (
                 "Look at this cafe image. "
                 "Are there too many people causing overcrowding? "
                 "Answer only Yes or No."
             )}
        ]
    }]

    prompt = vl_processor.apply_chat_template(
        messages,
        add_generation_prompt=True
    )

    inputs = vl_processor(
        text=prompt,
        images=image,
        return_tensors="pt"
    )

    with torch.no_grad():
        output = vl_model.generate(**inputs, max_new_tokens=10)

    answer = vl_processor.decode(output[0], skip_special_tokens=True)
    return "yes" in answer.lower()

# =============================
# ASYNC VLM WORKER
# =============================
def run_vlm_async(frame):
    global vlm_busy, vlm_result
    vlm_busy = True

    # ðŸ”¹ Downscale for speed
    small = cv2.resize(frame, (320, 240))
    vlm_result = qwen_confirm_overcrowding(small)

    vlm_busy = False

# =============================
# CAMERA
# =============================
cap = cv2.VideoCapture(CAMERA_ID, cv2.CAP_DSHOW)
cap.set(3, 640)
cap.set(4, 480)

# =============================
# STATE
# =============================
raw_counts = deque(maxlen=SMOOTHING_WINDOW)
alert_message = "ðŸŸ¢ Status: Normal"

# =============================
# MAIN LOOP
# =============================
while True:
    ret, frame = cap.read()
    if not ret:
        break

    # -------- YOLO DETECTION --------
    results = yolo_model(frame, conf=CONF_THRESHOLD, verbose=False)

    count = 0
    for r in results:
        for box in r.boxes:
            if int(box.cls[0]) == 0:
                count += 1
                x1, y1, x2, y2 = map(int, box.xyxy[0])
                cv2.rectangle(frame, (x1, y1), (x2, y2),
                              (0, 255, 0), 2)

    raw_counts.append(count)
    people_count = round(sum(raw_counts) / len(raw_counts))
    now = time.time()

    # -------- VLM TRIGGER (NON-BLOCKING) --------
    if people_count > OVER_CROWD_LIMIT:
        if not vlm_busy and (now - last_vlm_check) > VLM_CHECK_INTERVAL:
            last_vlm_check = now
            threading.Thread(
                target=run_vlm_async,
                args=(frame.copy(),),
                daemon=True
            ).start()

        if vlm_result:
            alert_message = "ðŸ”´ ALERT: Overcrowded (VLM Confirmed)"
            alert_active = True
            if not alert_thread_running:
                threading.Thread(target=alert_loop, daemon=True).start()
        else:
            alert_message = "ðŸŸ¡ Crowded but acceptable"
            alert_active = False
    else:
        alert_message = "ðŸŸ¢ Status: Normal"
        alert_active = False
        vlm_result = False

    # -------- UI --------
    cv2.putText(frame, "Cafe Monitoring (YOLO + Qwen2-VL)", (20, 30),
                cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)

    cv2.putText(frame, f"People Count: {people_count}", (20, 65),
                cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 255), 2)

    cv2.putText(frame, alert_message, (20, 105),
                cv2.FONT_HERSHEY_SIMPLEX, 0.8,
                (0, 0, 255) if "ALERT" in alert_message else (0, 255, 0), 2)

    cv2.imshow("YOLO + Qwen2-VL Overcrowding Monitor", frame)

    if cv2.waitKey(1) & 0xFF == ord("q"):
        break

cap.release()
cv2.destroyAllWindows()
